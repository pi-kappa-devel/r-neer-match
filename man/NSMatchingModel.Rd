% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matching_model.R
\name{NSMatchingModel}
\alias{NSMatchingModel}
\title{Neural-Symbolic Matching Model}
\usage{
NSMatchingModel(
  similarity_map,
  initial_feature_width_scales = 10L,
  feature_depths = 2L,
  initial_record_width_scale = 10L,
  record_depth = 4L,
  ...
)
}
\arguments{
\item{similarity_map}{A \code{\link{SimilarityMap}} object.}

\item{initial_feature_width_scales}{An integer or an integer vector of
initial feature width scales for each field-pair network. The scale is
multiplied by the number of similarities used in the field-pair network
to determine the number of units of the first dense layer. If the input is a
scalar, the same value is used for all field-pair networks.}

\item{feature_depths}{An integer or an integer vector of feature depths for
each field-pair network. The depth is the number of hidden dense layers
used in the field-pair network. If the input is a scalar, the same value is
used for all field-pair networks.}

\item{initial_record_width_scale}{An integer representing the initial record
width scale. The scale is multiplied by the number of field-pair networks
to determine the number of units of the first dense layer of the record-pair
network.}

\item{record_depth}{An integer representing the record depth. The depth is
the number of hidden dense layers used in the record-pair network.}

\item{...}{Additional arguments passed to the Python constructor. These
arguments are passed down to the
\href{https://www.tensorflow.org/api_docs/python/tf/keras/Model}{
\code{tf.keras.Model}} constructor.
constructor.}
}
\description{
Construct a neural-symbolic learning entity-matching model based on field
similarity encodings. The class wraps the constructor of the
\code{NSMatchingModel} Python class from the \code{neer-match} package.
The class is built using the \code{\link{tensorflow}} and
\href{https://pypi.org/project/ltn/}{\code{ltn}} frameworks.

The model uses the field-pair and record-pair networks of the
\code{\link{DLMatchingModel}} model as predicates. The fuzzy logic
component of the model aims to find weights for the predicates such
that for every matching example, at least one of the field-pair
predicates is (fuzzily) satisfied, and for every non-matching example,
not all of the field-pair predicates are (fuzzily) satisfied.

In addition to purely neural-symbolic models, i.e., models trained
using only the satisfiability loss, the class can also be used to
construct hybrid models. Hybrid models are trained using a weighted
average of the satisfiability and the binary cross-entropy losses.
}
\examples{
smap <- SimilarityMap(
  instructions = list(
    `z~w` = list("jaro", "levenshtein", "discrete"),
    `b ~ c` = list("jaro_winkler", "hamming")
  )
)
model <- NSMatchingModel(smap)
}
\seealso{
\code{\link{SimilarityMap}}
}
